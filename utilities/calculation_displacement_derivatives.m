%
% Calculation of the derivatives of the thrust generated by an oscillating 
% caudal fin. 
%
% Code developed for "Developing a bio-inspired underwater robot with a 
% morphing caudal fin for the surveillance of coral reefs", 2025
%
% authors: Davide Grande
% date: 04/06/2025
%

clear all
close all
clc

%% 1) Parameters 
interval_number = 100; % caveat: modified in section 3.
Dt = 0.001; % time step for the numerical integration

% The following parameters are selected as in ref #666. Uncomment to
% reproduce the results of the paper.
% A = pi*(0.165/2)^2; % [m]
% x = 0.36/3; % length of the caudal fin
% u = 0.08; % [m/s] surge speed
% rho = 1000; % [kg/m3]

% The following parameters are relative to OsCar are developed in this
% publication
A = 0.0194; % [m] OsCar, open caudal fin configuration
x = 0.131; % OsCar, length of the open caudal fin configuration
rho = 1000; % [kg/m3]
u = 0.184; % [m/s] surge speed


% Verification plots
theta_0 = 30.0; % [deg]
theta_max = 68.7549; % [deg]
f_min = 0.001; % [Hz]
f_max = 2.0; % [Hz]

compare_2D_3D = true; % flag to ensure that 2D and 3D derivatives are consistent
compare_at_freq = 1.00; % pick any frequency in the desired range [f_min, f_max]
compare_at_angle = 30.0; % pick any theta_0 in the desired range [0, theta_max]
debug_verbose = false; % enable this flag to print all the values of the derivative across all the 2D and 3D plots

% Thrust plot calculation
theta_0_thrust = 20.0; % [deg] - max angle for the calculation
f_min_thrust = 0.001; % [Hz]
f_max_thrust = 3.0; % [Hz]


% Relative error analysis between the two models
calculate_rmse = true; 
calculate_smape = true; % this was shown having numerical sensitivity as the signals are small. Not relevant


% Calculate force at specific frequency and amplitude
f_thrust_scalar = 2; % [Hz]
theta_0_thrust_scalar = deg2rad(30); % [rad]


%% Saving the expressions for convenience
% dh_dt = 2*pi*f*theta_0 * x * sec(theta_0 * sin(2*pi*f*t))^2 * cos(2*pi*f*t);
% dh_dx = tan(theta_0 * sin(2*pi*f*t)); 


%% 2) Verification plots, reproducing figures from "Li, Ren, Xu, 2016"

disp("Generating 2D derivatives...")
% 2.1) Frequency range plot
freq_range_verification = unique([linspace(f_min, f_max, interval_number), compare_at_freq]); % [Hz]
freq_range_verification = sort(freq_range_verification);
theta_0_verification = deg2rad(theta_0); % [rad]

dh_dt_square_verification = zeros(interval_number, 1);
dh_dx_square_verification = zeros(interval_number, 1);

for i_freq = 1:length(freq_range_verification)

    f_verification = freq_range_verification(i_freq);
    T = 1/f_verification;
    samples_per_period = ceil(T / Dt);

    % time derivative
    time_vect = linspace(0, T, samples_per_period); % time vector
    dh_dt_square_temp = trapz(time_vect, ...
        (2*pi*f_verification*theta_0_verification*x*sec(theta_0_verification*sin(2*pi*f_verification*time_vect)).^2.*cos(2*pi*f_verification*time_vect)).^2);
    dh_dt_square_verification(i_freq, 1) = 1/T * dh_dt_square_temp;


    % spatial derivative
    dh_dx_square_temp = trapz(time_vect,(tan(theta_0_verification*sin(2*pi*f_verification*time_vect))).^2);
    dh_dx_square_verification(i_freq, 1) = 1/T * dh_dx_square_temp;

end

% Fig 4. of "Li, Ren, Xu, 2016" (#666)
figure 
plot(freq_range_verification, dh_dt_square_verification, 'r', 'LineWidth', 2)
hold on 
plot(freq_range_verification, dh_dx_square_verification, '--b', 'LineWidth', 2)
xlabel("$f$ [Hz]",'Interpreter','latex')
legend('$(\partial h/\partial t)^2$', '$(\partial h/\partial x)^2$','Interpreter','latex')
grid on
fontsize(scale=1.35) 

% This does not generate exactly the same result of the paper. The spatial
% derivative should not depend on frequency when it is averaged over the
% full period, hence this result sounds plausible.

% This commented function is useful for debugging
% figure 
% plot(trapz(time_vect,(tan(theta_0_verification*sin(2*pi*f_verification*time_vect))).^2))


if compare_2D_3D
    [~, idx_f] = min(abs(freq_range_verification - compare_at_freq));
    
    freq_range_verification(idx_f);

    val_dh_dt_2d = dh_dt_square_verification(idx_f);
    val_dh_dx_2d = dh_dx_square_verification(idx_f);

    if debug_verbose
        disp("Verification of spatial derivative at " + freq_range_verification(idx_f) + " [Hz] and " + rad2deg(theta_0_verification) + " [deg]");
        val_dh_dt_2d
        val_dh_dx_2d
    end

end


% 2.2) Amplitude range plot
amplitude_range_verification = unique([linspace(deg2rad(0), deg2rad(theta_max), interval_number), deg2rad(compare_at_angle)]); % [rad]
amplitude_range_verification = sort(amplitude_range_verification);
f_verification = compare_at_freq; % [Hz]

dh_dt_square_verification = zeros(interval_number, 1);
dh_dx_square_verification = zeros(interval_number, 1);

for i_ampl = 1:length(amplitude_range_verification)

    T = 1/f_verification;
    theta_0_verification = amplitude_range_verification(i_ampl);
    samples_per_period = ceil(T / Dt);

    % time derivative
    time_vect = linspace(0, T, samples_per_period); % time vector
    dh_dt_square_temp = trapz(time_vect, ...
        (2*pi*f_verification*theta_0_verification*x*sec(theta_0_verification*sin(2*pi*f_verification*time_vect)).^2.*cos(2*pi*f_verification*time_vect)).^2);
    dh_dt_square_verification(i_ampl, 1) = 1/T * dh_dt_square_temp;


    % spatial derivative
    dh_dx_square_temp = trapz(time_vect, ... 
        (tan(theta_0_verification * sin(2*pi*f_verification*time_vect))).^2);
    dh_dx_square_verification(i_ampl, 1) = 1/T * dh_dx_square_temp;

end

% Fig 3. of "Li, Ren, Xu, 2016" (#666) and Fig. 3 of "McMasters et al. (#664)"
% (#664) (the latter uses different values)
figure 
plot(rad2deg(amplitude_range_verification), dh_dt_square_verification, 'r', 'LineWidth', 2)
hold on 
plot(rad2deg(amplitude_range_verification), dh_dx_square_verification, '--b', 'LineWidth', 2)
xlabel("Amplitude [deg]")
legend('$(\partial h/\partial t)^2$', '$(\partial h/\partial x)^2$','Interpreter','latex')
grid on
fontsize(scale=1.35) 


if compare_2D_3D
    [~, idx_t] = min(abs(amplitude_range_verification - deg2rad(compare_at_angle)));

    rad2deg(amplitude_range_verification(idx_t));

    val_dh_dt_2d = dh_dt_square_verification(idx_t);
    val_dh_dx_2d = dh_dx_square_verification(idx_t);

    if debug_verbose
        disp("Verification of temporal derivative at " + f_verification + " [Hz] and " + rad2deg(amplitude_range_verification(idx_t)) + " [deg]");
        val_dh_dt_2d
        val_dh_dx_2d
    end


end


% 3D view of the derivatives
disp("Generating 3D derivatives...")
interval_number = 100; % reduced from the original value to ease computational burden 
amplitude_range_verification = unique([linspace(deg2rad(0), deg2rad(theta_max), interval_number), deg2rad(compare_at_angle)]); % [rad]
amplitude_range_verification = sort(amplitude_range_verification);
freq_range_verification = unique([linspace(f_min, f_max, interval_number), compare_at_freq]); % [Hz]
freq_range_verification = sort(freq_range_verification);

dh_dt_square_3d = zeros(interval_number, interval_number);
dh_dx_square_3d = zeros(interval_number, interval_number);

for i_ampl = 1:length(amplitude_range_verification)

    for i_freq = 1:length(freq_range_verification)


        f_verification = freq_range_verification(i_freq);
        T = 1/f_verification;
        theta_0_verification = amplitude_range_verification(i_ampl);
        samples_per_period = ceil(T / Dt);
        time_vect = linspace(0, T, samples_per_period); % time vector
        
        % time derivative
        dh_dt_square_temp = trapz(time_vect, ...
            (2*pi*f_verification*theta_0_verification*x*sec(theta_0_verification*sin(2*pi*f_verification*time_vect)).^2.*cos(2*pi*f_verification*time_vect)).^2);
        dh_dt_square_3d(i_ampl, i_freq) = 1/T * dh_dt_square_temp;
    
        % spatial derivative
        dh_dx_square_temp = trapz(time_vect, ... 
            (tan(theta_0_verification * sin(2*pi*f_verification*time_vect))).^2);
        dh_dx_square_3d(i_ampl, i_freq) = 1/T * dh_dx_square_temp;

    end 

end


figure 
surf(freq_range_verification,rad2deg(amplitude_range_verification), dh_dt_square_3d)
xlabel("$f$ [Hz]",'Interpreter','latex')
ylabel("$\theta_0$ [deg]",'Interpreter','latex')
zlabel("$[m^2/s^2]$",'Interpreter','latex') 
title("$(\partial h/\partial t)^2$",'Interpreter','latex')
grid on



figure 
surf(freq_range_verification,rad2deg(amplitude_range_verification), dh_dx_square_3d)
xlabel("$f$ [Hz]",'Interpreter','latex')
ylabel("$\theta_0$ [deg]",'Interpreter','latex')
zlabel("adim.",'Interpreter','latex')
title("$(\partial h/\partial x)^2$",'Interpreter','latex')
grid on



if compare_2D_3D
    % Finally verifying consistency at f = compare_at_freq Hz and 
    % theta_0 = compare_at_angle deg of the 2D and 3D plots. 
    % If the values are not the same (+- epsilon), the execution is
    % interrupted here

    [~, idx_f] = min(abs(freq_range_verification - compare_at_freq));
    [~, idx_t] = min(abs(amplitude_range_verification - deg2rad(compare_at_angle)));

    freq_range_verification(idx_f);
    rad2deg(amplitude_range_verification(idx_t));

    val_dh_dt_3d = dh_dt_square_3d(idx_t, idx_f);
    val_dh_dx_3d = dh_dx_square_3d(idx_t, idx_f);

    assert(abs(val_dh_dt_3d - val_dh_dt_2d)<eps,'Temporal derivative Error','3D plot not correct') 
    assert(abs(val_dh_dx_3d - val_dh_dx_2d)<eps,'Spatial derivative Error','3D plot not correct') 


    if debug_verbose
        disp("Verification of 3D derivatives at " + freq_range_verification(idx_f) + " [Hz] and " + rad2deg(amplitude_range_verification(idx_t)) + " [deg]");
        val_dh_dt_3d
        val_dh_dx_2d
    end

    disp("Verification passed!")

end



%% 3) Plot thrust
disp("Generating trust comparisons...")

interval_number = 100; % reduced from the original value to ease computational burden 
amplitude_range_verification = linspace(0.0, deg2rad(theta_0_thrust), interval_number); % [rad]
freq_range_verification = linspace(f_min_thrust, f_max_thrust, interval_number); % [Hz]

dh_dt_square_torque = zeros(interval_number, interval_number);
dh_dx_square_torque = zeros(interval_number, interval_number);


for i_ampl = 1:length(amplitude_range_verification)

    for i_freq = 1:length(freq_range_verification)
    
        f_verification = freq_range_verification(i_freq);
        T = 1/f_verification;
        theta_0_verification = amplitude_range_verification(i_ampl);
        samples_per_period = ceil(T / Dt);

        time_vect = linspace(0, T, samples_per_period); % time vector

        % time derivative
        dh_dt_square_temp = trapz(time_vect, ...
            (2*pi*f_verification*theta_0_verification*x*sec(theta_0_verification*sin(2*pi*f_verification*time_vect)).^2.*cos(2*pi*f_verification*time_vect)).^2);
        dh_dt_square_torque(i_ampl, i_freq) = 1/T * dh_dt_square_temp;

        % spatial derivative
        dh_dx_square_temp = trapz(time_vect, ... 
            (tan(theta_0_verification * sin(2*pi*f_verification*time_vect))).^2);
        dh_dx_square_torque(i_ampl, i_freq) = 1/T * dh_dx_square_temp;
       
    end 

end


% Thrust -- CAVEAT: this requires "u"! Make sure to select appropriate
% values
T_fin = rho * A / 2 * (dh_dt_square_torque - u^2 .* dh_dx_square_torque);
% Reduced thrust propulsion model
T_fin_reduced = rho*A/2*dh_dt_square_torque;

% saving raw values
T_fin_raw = T_fin;
T_fin_reduced_raw = T_fin_reduced;

% removing spurious numerical elements
T_fin(T_fin< 1e-5) = NaN;
T_fin_reduced(T_fin_reduced<1e-5) = NaN;



figure 
surf(rad2deg(amplitude_range_verification), freq_range_verification, T_fin)
ylabel("$f$ [Hz]",'Interpreter','latex')
xlabel("$\theta_0$ [deg]",'Interpreter','latex')
zlabel("$T_f$ [N]", 'Interpreter','latex')
title("Full propulsion model")
grid on
fontsize(scale=1.35) 
grid minor
ax = gca;
ax.GridAlpha = 0.5;
ax.MinorGridAlpha = 0.3;



figure 
surf(rad2deg(amplitude_range_verification), freq_range_verification, T_fin_raw)
ylabel("$f$ [Hz]",'Interpreter','latex')
xlabel("$\theta_0$ [deg]",'Interpreter','latex')
zlabel("$T_f$ [N]", 'Interpreter','latex')
title("Full propulsion model (raw)")
grid on
fontsize(scale=1.35) 
grid minor
ax = gca;
ax.GridAlpha = 0.5;
ax.MinorGridAlpha = 0.3;


figure
surf(rad2deg(amplitude_range_verification), freq_range_verification, T_fin_reduced)
ylabel("$f$ [Hz]",'Interpreter','latex')
xlabel("$\theta_0$ [deg]",'Interpreter','latex')
zlabel("$T^r_{f}$ [N]", 'Interpreter','latex')
title('Reduced propulsion model')
grid on
fontsize(scale=1.35) 
grid minor
ax = gca;
ax.GridAlpha = 0.5;
ax.MinorGridAlpha = 0.3;

figure
surf(rad2deg(amplitude_range_verification), freq_range_verification, abs(T_fin-T_fin_reduced))
ylabel("$f$ [Hz]",'Interpreter','latex')
xlabel("$\theta_0$ [deg]",'Interpreter','latex')
zlabel("$T$ [N]", 'Interpreter','latex')
title('Difference between models')
grid on
fontsize(scale=1.35) 
grid minor
ax = gca;
ax.GridAlpha = 0.5;
ax.MinorGridAlpha = 0.3;



figure
surf(rad2deg(amplitude_range_verification), freq_range_verification, abs(T_fin_raw-T_fin_reduced_raw))
ylabel("$f$ [Hz]",'Interpreter','latex')
xlabel("$\theta_0$ [deg]",'Interpreter','latex')
zlabel("$T$ [N]", 'Interpreter','latex')
title('Difference between models (raw)')
grid on
fontsize(scale=1.35) 
grid minor
ax = gca;
ax.GridAlpha = 0.5;
ax.MinorGridAlpha = 0.3;



figure
surf(rad2deg(amplitude_range_verification), freq_range_verification, max(abs(T_fin), abs(T_fin_reduced)))
ylabel("$f$ [Hz]",'Interpreter','latex')
xlabel("$\theta_0$ [deg]",'Interpreter','latex')
zlabel("$T$ [N]", 'Interpreter','latex')
title('Max denominator between models (raw)')
grid on
fontsize(scale=1.35) 
grid minor
ax = gca;
ax.GridAlpha = 0.5;
ax.MinorGridAlpha = 0.3;


if calculate_rmse
    
    % calculation of the relative error
    err_rel_raw = abs(T_fin_raw-T_fin_reduced_raw) ./ max(abs(T_fin_raw), abs(T_fin_reduced_raw)) * 100;

    % Applying a corrective factor for small denominators
    numerator = abs(T_fin - T_fin_reduced);
    denominator = max(abs(T_fin), abs(T_fin_reduced)); % T_fin is the groundtruth, but the T_fin_reduced is always bigger by definition
    denominator_is_valid = denominator > 1e-2;
    numerator_is_valid = numerator > 1e-2;
    model_valid = denominator_is_valid & numerator_is_valid;
    err_rel = NaN(size(err_rel_raw));
    err_rel(model_valid) = numerator(model_valid) ./ denominator(model_valid) * 100;


    figure
    surf(rad2deg(amplitude_range_verification), freq_range_verification, err_rel)
    ylabel("$f$ [Hz]",'Interpreter','latex')
    xlabel("$\theta_0$ [deg]",'Interpreter','latex')
    zlabel("Rel. err [%]", 'Interpreter','latex')
    title('Error between models')
    grid on
    fontsize(scale=1.35) 
    grid minor
    ax = gca;
    ax.GridAlpha = 0.5;
    ax.MinorGridAlpha = 0.3;


    err_rel_mean_theta = mean(err_rel,1,"omitnan");
    figure
    plot(rad2deg(amplitude_range_verification), err_rel_mean_theta)
    ylabel("Rel. err [%]",'Interpreter','latex')
    xlabel("$\theta_0$ [deg]",'Interpreter','latex')
    title('Rel err vs $\theta_0$ [%]','Interpreter','latex')
    grid on
    fontsize(scale=1.35) 


    err_rel_mean_freq = mean(err_rel,2,"omitnan");
    figure
    plot(freq_range_verification, err_rel_mean_freq)
    ylabel("Rel. err [%]",'Interpreter','latex')
    xlabel("$f$ [Hz]",'Interpreter','latex')
    title('Rel err vs f [%]','Interpreter','latex')
    grid on
    fontsize(scale=1.35) 



end


if calculate_smape

    % Calculation of the symmetric mean absolute percentage error 
    SMAPE_raw = abs(T_fin - T_fin_reduced) ...
              ./ (0.5*(abs(T_fin) + abs(T_fin_reduced))) * 100;
    
    % Applying a corrective factor for small denominators
    numerator = abs(T_fin - T_fin_reduced);
    denominator = 0.5 * (abs(T_fin) + abs(T_fin_reduced));
    denominator_is_valid = denominator > 1e-2;
    numerator_is_valid = numerator > 1e-2;
    model_valid = denominator_is_valid & numerator_is_valid;
    
    SMAPE = NaN(size(SMAPE_raw));
    SMAPE(model_valid) = numerator(model_valid) ./ denominator((model_valid)) * 100;
    
    
    % Raw SMAPE 
    figure
    surf(rad2deg(amplitude_range_verification), freq_range_verification, SMAPE_raw)
    ylabel("$f$ [Hz]",'Interpreter','latex')
    xlabel("$\theta_0$ [deg]",'Interpreter','latex')
    zlabel("SMAPE [%]")
    title('SMAPE raw')
    grid on
    % colormap winter;
    
    
    % SMAPE with numerical corrections
    figure
    surf(rad2deg(amplitude_range_verification), freq_range_verification, SMAPE)
    ylabel("$f$ [Hz]",'Interpreter','latex')
    xlabel("$\theta_0$ [deg]",'Interpreter','latex')
    zlabel("SMAPE [%]")
    title('SMAPE')
    grid minor
    ax = gca;
    ax.GridAlpha = 0.5;
    ax.MinorGridAlpha = 0.3;
    % grid on
    % colormap winter;
    
    
    % only extracting the area where the model is "sufficiently" accuracy
    threshold_err = 100; % [%] of max error accepted between the two models
    valid_mask = SMAPE < threshold_err;
    SMAPE_plot = SMAPE;
    SMAPE_plot(~valid_mask) = NaN; % mask invalid values
    
    figure
    surf(rad2deg(amplitude_range_verification), freq_range_verification, SMAPE_plot')
    ylabel("$f$ [Hz]",'Interpreter','latex')
    xlabel("$\theta_0$ [deg]",'Interpreter','latex')
    zlabel("SMAPE [%]")
    title(['SMAPE < ', num2str(threshold_err), '%'])
    grid minor
    ax = gca;
    ax.GridAlpha = 0.5;
    ax.MinorGridAlpha = 0.3;
    % colorbar
    
    % Reduced SMAPE plot (only to angles < threshold)
    SMAPE_reduced = SMAPE;
    [theta_mesh, f_mesh] = meshgrid(rad2deg(amplitude_range_verification), freq_range_verification);
    SMAPE_reduced(theta_mesh < 10) = NaN; 
    
    figure
    surf(theta_mesh, f_mesh, SMAPE_reduced)
    ylabel("$f$ [Hz]",'Interpreter','latex')
    xlabel("$\theta_0$ [deg]",'Interpreter','latex')
    zlabel("SMAPE [%]")
    title("SMAPE $(\theta_0 \geq 10^{\circ})$",'Interpreter','latex')
    grid on

end


%% Desired force calculation -- these values are to compute the thrust force output at a specific 
% frequency, amplitude, area and fluid density. 

disp("Calculating thurst force at " + f_thrust_scalar + " [Hz], " + rad2deg(theta_0_thrust_scalar) + " [deg], and u=" + u + " [m/s] ...");


f_verification = f_thrust_scalar;
T = 1/f_verification;
theta_0_verification = theta_0_thrust_scalar;
samples_per_period = ceil(T / Dt);

time_vect = linspace(0, T, samples_per_period); % time vector

% time derivative
dh_dt_square_temp_thrust = trapz(time_vect, ...
    (2*pi*f_verification*theta_0_verification*x*sec(theta_0_verification*sin(2*pi*f_verification*time_vect)).^2.*cos(2*pi*f_verification*time_vect)).^2);
dh_dt_square_thrust = 1/T * dh_dt_square_temp_thrust;

% spatial derivative
dh_dx_square_temp_thrust = trapz(time_vect, ... 
    (tan(theta_0_verification * sin(2*pi*f_verification*time_vect))).^2);
dh_dx_square_thrust = 1/T * dh_dx_square_temp_thrust;

disp("Generate thrust force (full model) = ")
T_fin_model_complete = rho * A / 2 * (dh_dt_square_thrust - u^2 * dh_dx_square_thrust)

disp("Desired thrust force (reduced model) = ")
T_fin_model_reduced = rho * A / 2 * (dh_dt_square_thrust)