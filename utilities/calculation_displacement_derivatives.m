%
% Calculation of the derivatives of the thrust generated by an oscillating 
% caudal fin. 
%
% Developed for "Developing a bio-inspired underwater robot with a morphing 
% caudal fin for the surveillance of coral reefs", 2025
%
% authors: Davide Grande
% date: 04/06/2025
%

clear all
close all
clc

%% 1) Parameters 
interval_number = 100; % caveat: modified in section 3.
Dt = 0.001; % time step for the numerical integration

A = pi*(0.12/2)^2; % [m]
x = 0.36/3; % length of the caudal fin
rho = 1000; % [kg/m3]
u = 0.184; % [m/s] surge speed


% Verification plots
theta_0 = 30.0; % [deg]
f_min = 0.001; % [Hz]
f_max = 2.0; % [Hz]

% Thrust calculation
theta_0_thrust = 35.0; % [rad]
f_min_thrust = 0.001; % [Hz]
f_max_thrust = 3.0; % [Hz]



%% Saving the expressions for convenience
% dh_dt = 2*pi*f*theta_0 * x * sec(theta_0 * sin(2*pi*f*t))^2 * cos(2*pi*f*t);
% dh_dx = tan(theta_0 * sin(2*pi*f*t)); 


%% 2) Verification plots, reproducing figures from "Li, Ren, Xu, 2016"

disp("Generating 2D derivatives...")
% 2.1) Frequency range plot
freq_range_verification = linspace(f_min, f_max, interval_number); % [Hz]
theta_0_verification = deg2rad(theta_0); % [rad]

dh_dt_square_verification = zeros(interval_number, 1);
dh_dx_square_verification = zeros(interval_number, 1);

for i_freq = 1:length(freq_range_verification)

    f_verification = freq_range_verification(i_freq);
    T = 1/f_verification;

    % time derivative
    time_vect = linspace(0, T, 1000); % time vector
    dh_dt_square_temp = trapz(time_vect, ...
        (2*pi*f_verification*theta_0_verification*x*sec(theta_0_verification*sin(2*pi*f_verification*time_vect)).^2.*cos(2*pi*f_verification*time_vect)).^2);
    dh_dt_square_verification(i_freq, 1) = 1/T * dh_dt_square_temp;


    % spatial derivative
    dh_dx_square_temp = trapz(time_vect,(tan(theta_0_verification*sin(2*pi*f_verification*time_vect))).^2);
    dh_dx_square_verification(i_freq, 1) = 1/T * dh_dx_square_temp;

end

% Fig 4. of "Li, Ren, Xu, 2016" (#666)
figure 
plot(freq_range_verification, dh_dt_square_verification, 'r', 'LineWidth', 2)
hold on 
plot(freq_range_verification, dh_dx_square_verification, '--b', 'LineWidth', 2)
xlabel("$f$ [Hz]",'Interpreter','latex')
legend('$(\partial h/\partial t)^2$', '$(\partial h/\partial x)^2$','Interpreter','latex')
grid on
fontsize(scale=1.35) 

% This does not generate exactly the same result of the paper. The spatial
% derivative should not depend on frequency when it is averaged over the
% full period, hence this result sounds plausible.

% This commented function is useful for debugging
% figure 
% plot(trapz(time_vect,(tan(theta_0_verification*sin(2*pi*f_verification*time_vect))).^2))


% 2.2) Amplitude range plot
amplitude_range_verification = linspace(deg2rad(0), deg2rad(68.7549), interval_number); % [rad]
f_verification = 1; % [Hz]

dh_dt_square_verification = zeros(interval_number, 1);
dh_dx_square_verification = zeros(interval_number, 1);

for i_ampl = 1:length(amplitude_range_verification)

    T = 1/f_verification;
    theta_0_verification = amplitude_range_verification(i_ampl);

    % time derivative
    time_vect = linspace(0, T, 1000); % time vector
    dh_dt_square_temp = trapz(time_vect, ...
        (2*pi*f_verification*theta_0_verification*x*sec(theta_0_verification*sin(2*pi*f_verification*time_vect)).^2.*cos(2*pi*f_verification*time_vect)).^2);
    dh_dt_square_verification(i_ampl, 1) = 1/T * dh_dt_square_temp;


    % spatial derivative
    dh_dx_square_temp = trapz(time_vect, ... 
        (tan(theta_0_verification * sin(2*pi*f_verification*time_vect))).^2);
    dh_dx_square_verification(i_ampl, 1) = 1/T * dh_dx_square_temp;

end

% Fig 3. of "Li, Ren, Xu, 2016" (#666) and Fig. 3 of "McMasters et al. (#664)"
% (#664) (the latter uses different values)
figure 
plot(rad2deg(amplitude_range_verification), dh_dt_square_verification, 'r', 'LineWidth', 2)
hold on 
plot(rad2deg(amplitude_range_verification), dh_dx_square_verification, '--b', 'LineWidth', 2)
xlabel("Amplitude [deg]")
legend('$(\partial h/\partial t)^2$', '$(\partial h/\partial x)^2$','Interpreter','latex')
grid on
fontsize(scale=1.35) 


% 3D view of the derivatives
disp("Generating 3D derivatives...")
interval_number = 100; % reduced from the original value to ease computational burden 
amplitude_range_verification = linspace(deg2rad(0), deg2rad(68.7549), interval_number); % [rad]
freq_range_verification = linspace(f_min, f_max, interval_number); % [Hz]

dh_dt_square_3d = zeros(interval_number, interval_number);
dh_dx_square_3d = zeros(interval_number, interval_number);

for i_ampl = 1:length(amplitude_range_verification)

    for i_freq = 1:length(freq_range_verification)

        f_verification = freq_range_verification(i_freq);
        T = 1/f_verification;
        theta_0_verification = amplitude_range_verification(i_ampl);
    
        % samples_per_period = max(interval_number, ceil(T / Dt)); %
        % TODO_remove
        time_vect = linspace(0, T, 1000); % time vector
        
        % time derivative
        dh_dt_square_temp = trapz(time_vect, ...
            (2*pi*f_verification*theta_0_verification*x*sec(theta_0_verification*sin(2*pi*f_verification*time_vect)).^2.*cos(2*pi*f_verification*time_vect)).^2);
        dh_dt_square_3d(i_ampl, i_freq) = 1/T * dh_dt_square_temp;
    
        % spatial derivative
        dh_dx_square_temp = trapz(time_vect, ... 
            (tan(theta_0_verification * sin(2*pi*f_verification*time_vect))).^2);
        dh_dx_square_3d(i_ampl, i_freq) = 1/T * dh_dx_square_temp;

    end 

end


figure 
surf(freq_range_verification,rad2deg(amplitude_range_verification), dh_dt_square_3d)
xlabel("$f$ [Hz]",'Interpreter','latex')
ylabel("$\theta_0$ [deg]",'Interpreter','latex')
title("$(\partial h/\partial t)^2$",'Interpreter','latex')
grid on


figure 
surf(freq_range_verification,rad2deg(amplitude_range_verification), dh_dx_square_3d)
xlabel("$f$ [Hz]",'Interpreter','latex')
ylabel("$\theta_0$ [deg]",'Interpreter','latex')
title("$(\partial h/\partial x)^2$",'Interpreter','latex')
grid on



%% 3) Plot thrust
disp("Generating trust comparisons...")

interval_number = 100; % reduced from the original value to ease computational burden 
amplitude_range_verification = linspace(0.0, deg2rad(theta_0_thrust), interval_number); % [rad]
freq_range_verification = linspace(f_min_thrust, f_max_thrust, interval_number); % [Hz]

dh_dt_square_torque = zeros(interval_number, interval_number);
dh_dx_square_torque = zeros(interval_number, interval_number);
T_fin_reduced = zeros(interval_number, interval_number);
T_fin_reduced_explicit = zeros(interval_number, interval_number);
T_fin_oscar = zeros(interval_number, interval_number);


for i_ampl = 1:length(amplitude_range_verification)

    for i_freq = 1:length(freq_range_verification)

        f_verification = freq_range_verification(i_freq);
        T = 1/f_verification;
        theta_0_verification = amplitude_range_verification(i_ampl);
    
        % time derivative
        samples_per_period = max(interval_number, ceil(T / Dt));
        time_vect = linspace(0, T, samples_per_period); % time vector
        dh_dt_square_temp = trapz(time_vect, ...
            (2*pi*f_verification*theta_0_verification*x*sec(theta_0_verification*sin(2*pi*f_verification*time_vect)).^2.*cos(2*pi*f_verification*time_vect)).^2);
        dh_dt_square_torque(i_ampl, i_freq) = 1/T * dh_dt_square_temp;
    
        % spatial derivative
        dh_dx_square_temp = trapz(time_vect, ... 
            (tan(theta_0_verification * sin(2*pi*f_verification*time_vect))).^2);
        dh_dx_square_torque(i_ampl, i_freq) = 1/T * dh_dx_square_temp;

        
        % Model neglecting the spacial derivative
        T_fin_reduced_explicit_temp = trapz(time_vect, ... 
            rho*A/2*4*pi^2*f_verification^2*theta_0_verification^2*x^2*sec(theta_0_verification*sin(2*pi*f_verification*time_vect)).^4.*cos(2*pi*f_verification*time_vect).^2);
        T_fin_reduced_explicit(i_ampl, i_freq) = 1/T * T_fin_reduced_explicit_temp;


        % Model derived
        T_fin_oscar_temp = trapz(time_vect, ... 
            2*rho*A*x^2*theta_0_verification^2*pi^2*f_verification^2*cos(2*pi*f_verification*time_vect).^2.*cos(theta_0_verification*sin(2*pi*f_verification*time_vect)).^2);
        T_fin_oscar(i_ampl, i_freq) = 1/T * T_fin_oscar_temp;

    end 

end



% Thrust -- CAVEAT: this requires "u"! Make sure to select appropriate
% values
T_fin = rho * A / 2 * (dh_dt_square_torque - u^2 .* dh_dx_square_torque);

figure 
surf(rad2deg(amplitude_range_verification), freq_range_verification, T_fin)
ylabel("$f$ [Hz]",'Interpreter','latex')
xlabel("$\theta_0$ [deg]",'Interpreter','latex')
zlabel("$T_f$ [N]", 'Interpreter','latex')
title("Full propulsion model")
grid on


figure
surf(rad2deg(amplitude_range_verification), freq_range_verification, T_fin_reduced_explicit)
ylabel("$f$ [Hz]",'Interpreter','latex')
xlabel("$\theta_0$ [deg]",'Interpreter','latex')
zlabel("$T_f$ [N]", 'Interpreter','latex')
title('Reduced propulsion model')
grid on


figure
surf(rad2deg(amplitude_range_verification), freq_range_verification, T_fin-T_fin_reduced_explicit)
ylabel("$f$ [Hz]",'Interpreter','latex')
xlabel("$\theta_0$ [deg]",'Interpreter','latex')
zlabel("$T_f$ [N]", 'Interpreter','latex')
title('Difference between models')
grid on



figure
surf(rad2deg(amplitude_range_verification), freq_range_verification, T_fin-T_fin_oscar)
ylabel("$f$ [Hz]",'Interpreter','latex')
xlabel("$\theta_0$ [deg]",'Interpreter','latex')
zlabel("$T_f$ [N]", 'Interpreter','latex')
title('Difference between models (OsCar)')
grid on



% Calculation of the symmetric mean absolute percentage error 
SMAPE = abs(T_fin_reduced_explicit - T_fin) ...
          ./ (0.5*(abs(T_fin) + abs(T_fin_reduced_explicit))) * 100;


% Full error
figure
surf(rad2deg(amplitude_range_verification), freq_range_verification, SMAPE)
ylabel("$f$ [Hz]",'Interpreter','latex')
xlabel("$\theta_0$ [deg]",'Interpreter','latex')
zlabel("SMAPE [%]")
title('SMAPE')
grid on


% Reduced plot
SMAPE_reduced = SMAPE;
[theta_mesh, f_mesh] = meshgrid(rad2deg(amplitude_range_verification), freq_range_verification);   % both are M × N

SMAPE_reduced(theta_mesh < 10) = NaN;                   % mask

figure
surf(theta_mesh, f_mesh, SMAPE_reduced)
ylabel("$f$ [Hz]",'Interpreter','latex')
xlabel("$\theta_0$ [deg]",'Interpreter','latex')
zlabel("SMAPE [%]")
title("SMAPE $(\theta_0 \geq 10^{\circ})$",'Interpreter','latex')
grid on






%% Reduced plot OsCar
% Calculation of the symmetric mean absolute percentage error 
SMAPE_oscar = abs(T_fin_oscar - T_fin) ...
          ./ (0.5*(abs(T_fin) + abs(T_fin_oscar))) * 100;

SMAPE_reduced_oscar = SMAPE_oscar;
[theta_mesh, f_mesh] = meshgrid(rad2deg(amplitude_range_verification), freq_range_verification);   % both are M × N

SMAPE_reduced_oscar(theta_mesh < 10) = NaN;                   % mask


% Full error OsCar
figure
surf(rad2deg(amplitude_range_verification), freq_range_verification, SMAPE_oscar)
ylabel("$f$ [Hz]",'Interpreter','latex')
xlabel("$\theta_0$ [deg]",'Interpreter','latex')
zlabel("SMAPE [%]")
title('SMAPE OsCar')
grid on

% Reduced OsCar
figure
surf(theta_mesh, f_mesh, SMAPE_reduced_oscar)
ylabel("$f$ [Hz]",'Interpreter','latex')
xlabel("$\theta_0$ [deg]",'Interpreter','latex')
zlabel("SMAPE OsCar [%]")
title("SMAPE $(\theta_0 \geq 10^{\circ})$",'Interpreter','latex')
grid on




%% Desired force calculation -- these values are to compute the thrust force output at a specific 
% frequency, amplitude, area and fluid density. 
disp("Calculating thurst force...")

f_desired = 2;
theta_0_desired = deg2rad(30);
rho = 1000; % [kg/m3]
A = pi*(0.12/2)^2; % [m]
u = 0.184; % [m/s] surge speed


f = f_desired;
theta_0 = theta_0_desired;

for i_t = 1:length(time_vect)
    t = time_vect(i_t);
    dh_dt_square_temp = dh_dt_square_temp + Dt * (2*pi*f*theta_0 * x * sec(theta_0 * sin(2*pi*f*t))^2 * cos(2*pi*f*t))^2;
end 
dh_dt_square_desired = 1/T * dh_dt_square_temp;

% spatial derivative
dh_dx_square_temp = 0;
time_vect = linspace(0, T, 1/Dt); % time vector
for i_t = 1:length(time_vect)
    t = time_vect(i_t);
    dh_dx_square_temp = dh_dx_square_temp + Dt * (tan(theta_0 * sin(2*pi*f*t)))^2;
end 
dh_dx_square_desired = 1/T * dh_dx_square_temp;

disp("Desired force = ")
T_fin_desired = rho * A / 2 * (dh_dt_square_desired - u^2 * dh_dx_square_desired)



