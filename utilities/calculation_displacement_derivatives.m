%
% Calculation of the derivatives for the calculation of the thrust
% generated by an oscillating caudal fin. 
%
% Developed for "Developing a bio-inspired underwater robot with a morphing 
% caudal fin for the surveillance of coral reefs", 2025
%
% authors: Davide Grande
% date: 04/06/2025
%

clear all
close all 
clc

%% 1) Parameters 
interval_number = 10; % caveat: modified in section 3.
Dt = 0.001; % time step for the numerical integration

A = pi*(0.12/2)^2; % [m]
x = 0.36/3; % length of the caudal fin
rho = 1000; % [kg/m3]
u = 0.184; % [m/s] surge speed



%% Saving the expressions for convenience
% dh_dt = 2*pi*f*theta_0 * x * sec(theta_0 * sin(2*pi*f*t))^2 * cos(2*pi*f*t);
% dh_dx = tan(theta_0 * sin(2*pi*f*t)); 


%% 2) Verification plots, reproducing figures from "Li, Ren, Xu, 2016"

% 2.1) Frequency range plot
freq_range_verification = linspace(0.001, 2.0, interval_number); % [Hz]
theta_0_verification = deg2rad(30); % [rad]

dh_dt_square_verification = zeros(interval_number, 1);
dh_dx_square_verification = zeros(interval_number, 1);

for i_freq = 1:length(freq_range_verification)

    f_verification = freq_range_verification(i_freq);
    T = 1/f_verification;

    % time derivative
    time_vect = linspace(0, T, 1/Dt); % time vector
    dh_dt_square_temp = trapz(time_vect, ...
        (2*pi*f_verification*theta_0_verification*x*sec(theta_0_verification*sin(2*pi*f_verification*time_vect)).^2.*cos(2*pi*f_verification*time_vect)).^2);
    dh_dt_square_verification(i_freq, 1) = 1/T * dh_dt_square_temp;


    % spatial derivative
    dh_dx_square_temp = trapz(time_vect,(tan(theta_0_verification*sin(2*pi*f_verification*time_vect))).^2);
    dh_dx_square_verification(i_freq, 1) = 1/T * dh_dx_square_temp;

end

% Fig 4. of "Li, Ren, Xu, 2016" (#666)
figure 
plot(freq_range_verification, dh_dt_square_verification, 'r', 'LineWidth', 2)
hold on 
plot(freq_range_verification, dh_dx_square_verification, '--b', 'LineWidth', 2)
xlabel("$f$ [Hz]",'Interpreter','latex')
legend('$(\partial h/\partial t)^2$', '$(\partial h/\partial x)^2$','Interpreter','latex')
grid on
% This does not generate exactly the same result of the paper. The spatial
% derivative should not depend on frequency when it is averaged over the
% full period, hence this result sounds plausible.

% This commented function is useful for debugging
% figure 
% plot(trapz(time_vect,(tan(theta_0_verification*sin(2*pi*f_verification*time_vect))).^2))


% 2.2) Amplitude range plot
amplitude_range_verification = linspace(deg2rad(0), deg2rad(68.7549), interval_number); % [rad]
f_verification = 1; % [Hz]

dh_dt_square_verification = zeros(interval_number, 1);
dh_dx_square_verification = zeros(interval_number, 1);

for i_ampl = 1:length(amplitude_range_verification)

    T = 1/f_verification;
    theta_0_verification = amplitude_range_verification(i_ampl);

    % time derivative
    time_vect = linspace(0, T, 1/Dt); % time vector
    dh_dt_square_temp = trapz(time_vect, ...
        (2*pi*f_verification*theta_0_verification*x*sec(theta_0_verification*sin(2*pi*f_verification*time_vect)).^2.*cos(2*pi*f_verification*time_vect)).^2);
    dh_dt_square_verification(i_ampl, 1) = 1/T * dh_dt_square_temp;


    % spatial derivative
    dh_dx_square_temp = trapz(time_vect, ... 
        (tan(theta_0_verification * sin(2*pi*f_verification*time_vect))).^2);
    dh_dx_square_verification(i_ampl, 1) = 1/T * dh_dx_square_temp;

end

% Fig 3. of "Li, Ren, Xu, 2016" (#666) and Fig. 3 of "McMasters et al. (#664)"
% (#664) (the latter uses different values)
figure 
plot(rad2deg(amplitude_range_verification), dh_dt_square_verification, 'r', 'LineWidth', 2)
hold on 
plot(rad2deg(amplitude_range_verification), dh_dx_square_verification, '--b', 'LineWidth', 2)
xlabel("Amplitude [deg]")
legend('$(\partial h/\partial t)^2$', '$(\partial h/\partial x)^2$','Interpreter','latex')
grid on



%% 3) Plot thrust
interval_number = 100; % reduced from the original value to easecomputational burden 
amplitude_range_verification = linspace(deg2rad(-35), deg2rad(35), interval_number); % [rad]
freq_range_verification = linspace(0.000001, 3.0, interval_number); % [Hz]

dh_dt_square_torque = zeros(interval_number, interval_number);
dh_dx_square_torque = zeros(interval_number, interval_number);
T_fin_simplified = zeros(interval_number, interval_number);
T_fin_simplified_explicit = zeros(interval_number, interval_number);


for i_ampl = 1:length(amplitude_range_verification)

    for i_freq = 1:length(freq_range_verification)

        f_verification = freq_range_verification(i_freq);
        T = 1/f_verification;
        theta_0_verification = amplitude_range_verification(i_ampl);
    
        % time derivative
        time_vect = linspace(0, T, 1/Dt); % time vector
        dh_dt_square_temp = trapz(time_vect, ...
            (2*pi*f_verification*theta_0_verification*x*sec(theta_0_verification*sin(2*pi*f_verification*time_vect)).^2.*cos(2*pi*f_verification*time_vect)).^2);
        dh_dt_square_torque(i_ampl, i_freq) = 1/T * dh_dt_square_temp;
    
        % spatial derivative
        dh_dx_square_temp = trapz(time_vect, ... 
            (tan(theta_0_verification * sin(2*pi*f_verification*time_vect))).^2);
        dh_dx_square_torque(i_ampl, i_freq) = 1/T * dh_dx_square_temp;


        T_fin_simplified_explicit_temp = trapz(time_vect, ... 
            rho*A/2*4*pi^2*f_verification^2*theta_0_verification^2*x^2*sec(theta_0_verification*sin(2*pi*f_verification*time_vect)).^4.*cos(2*pi*f_verification*time_vect).^2);
        T_fin_simplified_explicit(i_ampl, i_freq) = 1/T * T_fin_simplified_explicit_temp;

    end 

end


% Thrust -- CAVEAT: this requires "u"! Make sure to select appropriate
% values
T_fin = rho * A / 2 * (dh_dt_square_torque - u^2 .* dh_dx_square_torque);

figure 
surf(rad2deg(amplitude_range_verification), freq_range_verification, T_fin)
ylabel("$f$ [Hz]",'Interpreter','latex')
xlabel("\theta_0 [deg]")
zlabel("thrust [N]")
title("Full propulsion model")
grid on


figure
surf(rad2deg(amplitude_range_verification), freq_range_verification, T_fin-T_fin_simplified_explicit)
ylabel("$f$ [Hz]",'Interpreter','latex')
xlabel("\theta_0 [deg]")
zlabel("thrust [N]")
title('Difference between models')
grid on


figure
surf(rad2deg(amplitude_range_verification), freq_range_verification, T_fin_simplified_explicit)
ylabel("$f$ [Hz]",'Interpreter','latex')
xlabel("\theta_0 [deg]")
zlabel("thrust [N]")
title('Simplified models')
grid on


% Calculation of the relative error
rel_err = abs(T_fin_simplified_explicit - T_fin) ./ abs(T_fin);
rel_err = abs(T_fin_simplified_explicit - T_fin) ./ max(abs(T_fin), eps);  % eps avoids division by zero

figure
surf(rad2deg(amplitude_range_verification), freq_range_verification, rel_err)
ylabel("$f$ [Hz]",'Interpreter','latex')
xlabel("\theta_0 [deg]")
zlabel("thrust [N]")
title('Relative error')
grid on


%% Desired force calculation -- these values are to compute the thrust force output at a specific 
% frequency, amplitude, area and fluid density. 
f_desired = 2;
theta_0_desired = deg2rad(30);
rho = 1000; % [kg/m3]
A = pi*(0.12/2)^2; % [m]
u = 0.184; % [m/s] surge speed


f = f_desired;
theta_0 = theta_0_desired;

for i_t = 1:length(time_vect)
    t = time_vect(i_t);
    dh_dt_square_temp = dh_dt_square_temp + Dt * (2*pi*f*theta_0 * x * sec(theta_0 * sin(2*pi*f*t))^2 * cos(2*pi*f*t))^2;
end 
dh_dt_square_desired = 1/T * dh_dt_square_temp;

% spatial derivative
dh_dx_square_temp = 0;
time_vect = linspace(0, T, 1/Dt); % time vector
for i_t = 1:length(time_vect)
    t = time_vect(i_t);
    dh_dx_square_temp = dh_dx_square_temp + Dt * (tan(theta_0 * sin(2*pi*f*t)))^2;
end 
dh_dx_square_desired = 1/T * dh_dx_square_temp;

disp("Desired force = ")
T_fin_desired = rho * A / 2 * (dh_dt_square_desired - u^2 * dh_dx_square_desired)



